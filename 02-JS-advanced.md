
## JS advanced

### - Modules (CommonJS, AMD, UMD)

Для зручності програмування використовують модульну систему побудови структури прєкту. Де модулем виступає окремий файл з певною частиною коду програми, 
для того щоб зєднати ці системи з окремих файлів зявились бібліотеки які реалізовують зв'язок між модулями.
CommonJS - реалізований за допомогою бібліотеки RequireJS спосіб завантаження модулів.
AMD - асинхронне визначення модулів, використовується в браузерах визначається функцією define з масивом залежностей та фабричною функцією. 
UMD - універсальний шаблон, суміш common та amd в вигляді IIFE функції.
Але це все застаріло так як зараз можна в більшості випадків застосовувати import :)

### - Set, WeakSet, Map, WeakMap

Відносно нові способи зберігання даних які зявились з es2015 коротко і по порядку:

Set - колекція даних яка зберігає в собі тільки унікальні значення. 

Основні методи:

set.add(item) – додає в колекцію item, повертає set.
set.delete(item) – видаляє item з колекції, повертає true, якщо він там був, якщо ні false.
set.has(item) – повертає true, якщо item є в колекції, якщо ні false.
set.clear() – очищає set.

Map - колекція для збереження записів типу ключ значення, в якому ключ може бути будь якого типу (в звичайному об'єкті в нас тільки стрінга);

Основні методи:

map.size - зберігає в собі кількість записів.
map.delete(key)-видаляє item з колекції, повертає true, якщо він там був, якщо ні false.
map.clear() - очищає map;
map.has(key) - повертає true, якщо ключ є в колекції, якщо ні false.
map.keys() - повертає ітеруємий об'єкт дял ключів
map.values() - те саме тільки для значень 
map.entries() -  повертає ітеруємий об'єкт для значень [ключ, значення], по замовчуванню використовує for of.

п.с. ітерація здійснюється в порядку запису (в звичайному в нас йде сортування по алфавіту)
п.с.с. В Set та Map є вбудований метод ітерації forEach який аналогічний методу з цією назвою що використовується в масивах. 

WeakSet та WeakMap - особливі види того що описано вище, вони не перешкоджають збірнику мусору робити свою роботу. 
Тобто якщо посилання на об'єкт залишилась тільки WeakSet/WeakMap то вона буде видалена. 

У WeakMap є обмеження:
Тільки обєкти в якості ключів.
Відсутня властивість size.
Неможна перебирати властивості ітератором або forEach.
Немає можливості очистити колекцію за допомогою методу clear().

У WeakSet аналогічно обрізаний функціонал, можна додавати елементи, перевіряти їх наявність, але не можна отримати їх список чи дізнатись кількість. 

### - WebAssembly

WebAssembly - байт код який використовується для перенесення нашого коду на низькорівневі асемблерні інструкції. 

### - Shared Memory and Atomics

Це треба буде уточнити, не пам'ятаю що б таке вчив. 

### - Generators, Symbol

Generators - щось багато в анс особливих функції, але це ще одна. Отже функція генератор дозволяє нам за допомогою ключового слова yeild повертати
декілька значень одне за одним по мірі необхідності, основним методом функції генератора є метод next результатом виклику якого є завжди є об'єкт
з двома властивостями value: значення з yield та done: true, якщо виконання функції завершено, або false якщо ні. А ще дані функції можна перебирати за допомогою
циклу for of що виглядає набагто красивіше ніж використовувати generator.next().value

Symbol - тут напевно треба буде розказати що таке тип даних символ, а опісля переходити до функції Symbol про яку тут і питають і яка повертає значення типу 
символ, має статичні властивості, методи які дають доступ до реєстру глобальних символів та нагадує вбудований клас об'єкта. Symbol не є повноцінним конструктором оскільки не підтримсує ключов слово new. Символьне значення може використовуватись в якості ідентифікатора властивостей об'єкта; це єдина мета цього типу даних.

### - Event Loop

Event Loop - js це однопотокова мова програмування, на практиці це означає що js виконується по порядку та нативно не є асинхронним. Але по порядку 
у нас є "купа" яка є назвою для позначення великої (здебільшого не структурованої) області памяті. Елементи цієї купи при виклику потряпляють в стек фреймів, 
та виконуються за принципом перший прийшов останій пішов, тобто в зворотньому порядку попадання в стек. Але якщо в нас мова сама пособі є синхронною тоді як працювати з асинхронними запитами ? Тут нам на допомого приходять вебворкери, які створють окремий потік та в якому опрацювується наша асинхронна справа :) після виконання якої вона потрапляє в чергу яка містить список повідомлень що мають бути опрацьовані. Кожне повідомлення має пов'язану функцію, яка викликається для обробки цього повідомлення та потрапляє в стек у порядку перший прийшов перший пішов. 

